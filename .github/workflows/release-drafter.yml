name: Create Release
on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      # Checkout the code
      - name: Checkout code
        uses: actions/checkout@v2
        with:
          fetch-depth: 0

      # Set up GitHub CLI and jq
      - name: Set up GitHub CLI and jq
        run: |
          sudo apt update
          sudo apt install -y gh jq
          echo "${{ secrets.GITHUB_TOKEN }}" | gh auth login --with-token

      # Get the latest release tag
      - name: Get latest release tag
        id: get_latest_release
        run: |
          LATEST_TAG=$(git tag --sort=-v:refname | head -n 1 || echo "v0.0.0")
          echo "LATEST_TAG=$LATEST_TAG" >> $GITHUB_ENV

      # Get merged PRs since the latest tag
      - name: Get merged PRs since last release
        id: pr_data
        run: |
          LATEST_TAG="$LATEST_TAG"
          PR_DATA=$(gh pr list --state merged --base main --search "merged:>$LATEST_TAG" --json title,labels,body)
          echo "$PR_DATA" > pr_data.json
          echo "PR_DATA=$PR_DATA" >> $GITHUB_ENV

      # Determine the bump type using title and labels
      - name: Determine bump type
        id: bump_type
        run: |
          PR_DATA=$(cat pr_data.json)

          # Default to "patch"
          BUMP_TYPE="patch"

          # Check PR titles for explicit keywords
          if echo "$PR_DATA" | jq -e '.[] | select(.title | test("\\bmajor\\b"))' >/dev/null; then
              BUMP_TYPE="major"
          elif echo "$PR_DATA" | jq -e '.[] | select(.title | test("\\bminor\\b"))' >/dev/null; then
              BUMP_TYPE="minor"
          elif echo "$PR_DATA" | jq -e '.[] | select(.title | test("\\bpatch\\b"))' >/dev/null; then
              BUMP_TYPE="patch"
          else
              # If no title-based keywords, fallback to label-based logic
              if echo "$PR_DATA" | jq -e '.[] | select(.labels[]?.name == "major" or .labels[]?.name == "breaking-change")' >/dev/null; then
                  BUMP_TYPE="major"
              elif echo "$PR_DATA" | jq -e '.[] | select(.labels[]?.name == "minor" or .labels[]?.name == "feature" or .labels[]?.name == "enhancement")' >/dev/null; then
                  BUMP_TYPE="minor"
              elif echo "$PR_DATA" | jq -e '.[] | select(.labels[]?.name == "patch" or .labels[]?.name == "fix" or .labels[]?.name == "bug" or .labels[]?.name == "chore" or .labels[]?.name == "maintenance")' >/dev/null; then
                  BUMP_TYPE="patch"
              fi
          fi

          echo "BUMP_TYPE=$BUMP_TYPE" >> $GITHUB_ENV
          echo "::set-output name=bump_type::$BUMP_TYPE"

      # Calculate next version
      - name: Calculate next version
        id: next_version
        run: |
          LATEST_TAG="$LATEST_TAG"
          VERSION=${LATEST_TAG#v}
          IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION"

          if [ "$BUMP_TYPE" = "major" ]; then
            MAJOR=$((MAJOR + 1))
            MINOR=0
            PATCH=0
          elif [ "$BUMP_TYPE" = "minor" ]; then
            MINOR=$((MINOR + 1))
            PATCH=0
          else
            PATCH=$((PATCH + 1))
          fi

          NEW_VERSION="v$MAJOR.$MINOR.$PATCH"
          echo "NEW_VERSION=$NEW_VERSION" >> $GITHUB_ENV
          echo "::set-output name=new_version::$NEW_VERSION"

      # Generate release notes for PRs since the last tag
      - name: Generate Release Notes
        id: release_notes
        run: |
          PR_DATA=$(cat pr_data.json)
          RELEASE_NOTES=$(echo "$PR_DATA" | jq -r '
            group_by(.labels | map(.name) | flatten | map(select(. == "feature" or . == "bug" or . == "breaking-change"))) |
            map({
              "category": (
                if any(.labels[]?.name == "feature") then "Features"
                elif any(.labels[]?.name == "bug") then "Bug Fixes"
                elif any(.labels[]?.name == "breaking-change") then "Breaking Changes"
                else "Other" end
              ),
              "notes": (map("\(.title): \(.body)") | join("\n"))
            }) |
            .[] |
            "## " + .category + "\n" + .notes
          ')
          echo "$RELEASE_NOTES" > release_notes.md
          echo "Release notes generated and saved to release_notes.md."

      # Create a release with the new version and release notes
      - name: Create Release
        id: create_release
        run: |
          NEW_VERSION="${{ steps.next_version.outputs.new_version }}"
          RELEASE_NOTES=$(cat release_notes.md)
          gh release create "$NEW_VERSION" --notes "$RELEASE_NOTES" --title "Release $NEW_VERSION"
